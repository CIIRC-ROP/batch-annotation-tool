#!/usr/bin/env python3

""" klikatko: Annotation tool

Usage:
  klikatko -h | --help
  klikatko [options]
  klikatko [options] <imfile> <attfile> <outfile>

Options:
  -h, --help
  --config CONFIG    Specifi config file
  --debug            Run in debug mode
  --fullscreen       Display in fullscreen
"""

from klikatko import Config

from PIL import Image, ImageTk
from docopt import docopt
from itertools import product, islice
import numpy as np
import tkinter as tk
from tkinter import ttk, filedialog
import logging
import pandas as pd
import os

import sqlite3 as sqlite
import io

# main logger
log = logging.getLogger("Klikatko")


def main():
    opt = docopt(__doc__)

    # setup logging
    setup_logging(level="DEBUG" if opt["--debug"] else "INFO")
    log.debug("Command line options:\n%s", str(opt))

    # initialize config
    if opt["--config"] is None:
        opt["--config"] = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'klikatko.json')
        log.debug("Lookin for config in %s", opt['--config'])
    conf = Config(opt["--config"])

    # gui root
    root = tk.Tk()

    # prepare database
    sampledb = SQLiteDB(opt['<imfile>'], opt['<attfile>'], opt['<outfile>'], 'backpack')

    # if fullscreen open in fullscreen otherwise use geometry in conf file
    if opt['--fullscreen']:
        root.geometry("{0}x{1}+0+0".format(root.winfo_screenwidth(), root.winfo_screenheight()))
    else:
        root.geometry(conf["geometry"])

    # initialize the app
    app = KlikatkoApp(sampledb, master=root)

    # set quit functions
    root.protocol("WM_DELETE_WINDOW", app.on_quit)

    # run main loop
    app.mainloop()


def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d


class SQLiteDB(object):

    def __init__(self, imdbpath, attdbpath, outpath, attname):
        self.con_img = sqlite.connect(imdbpath)
        self.con_img.row_factory = dict_factory
        self.con_att = sqlite.connect(attdbpath)
        self.con_att.row_factory = dict_factory
        self.cur_img = self.con_img.cursor()
        self.cur_att = self.con_att.cursor()

        self.img_table = 'test_images'
        self.att_table = 'test_attributes'
        self.attname = attname
        self.im_size = [100, 40]

        self.con_out = sqlite.connect(outpath)
        self.cur_out = self.con_out.cursor()

    def get_image_size(self):
        return self.im_size

    def close(self):
        self.con_img.close()
        self.con_att.close()

    def get_first_unannotated(self, column=None):
        item = self.cur_att.execute('SELECT id FROM {} WHERE {}>=0'.format(self.att_table, self.attname)).fetchone()
        return item['id']

    def chunk(self, start, n):
        chunk = self.cur_att.execute('SELECT id, ? FROM {} WHERE id>=? AND id<?'.format(self.att_table), (self.attname, start, start+n)).fetchall()
        return chunk

    def annotate(self, iid, value, column=None):
        self.cur_att.execute('UPDATE ? SET ?=? WHERE id=?', (self.att_table, self.attname, value, iid))

    def imread(self, iid):
        sample = self.con_img.execute('SELECT * FROM {} WHERE id=?'.format(self.img_table), (iid,)).fetchone()
        image = Image.open(io.BytesIO(sample['blob']))
        image.thumbnail(self.im_size)
        return image

    def write(self):
        pass


class SampleDB(object):

    def __init__(self, filename, outcolumn, incolumn=None, default=''):
        self.dbfilename = filename
        log.info("DB file: %s", self.dbfilename)

        self.base_path = os.path.dirname(self.dbfilename)
        log.info("Base path: %s", self.base_path)

        # get image size
        self.first_image = None
        self.im_size = None
        log.info("Image size: %s", str(self.get_image_size()))

        # config
        self.conf = Config()
        self.column_path = self.conf["column_path"]
        self.column_in = self.conf["column_in"]
        self.column_out = self.conf["column_out"]

        # table of paths and annotations
        self.table = pd.read_csv(self.dbfilename,
                                 sep=self.conf["csv_sep"],
                                 decimal=self.conf["csv_decimal"],
                                 header=None)

        self.table = pd_ensure_columns(self.table, max(self.column_in, self.column_out)+1)
        self.N = self.table.shape[0]
        log.debug("DB shape: %s", str(self.table.shape))

    def get_image_size(self):
        if self.im_size is None:
            # get size of the imag
            with open(self.dbfilename, "r") as f:
                _ = f.readline()
                line = f.readline()
                imagefile = line.split(";")[0]
                self.first_image = os.path.join(self.base_path, imagefile)

                with Image.open(self.first_image) as im:
                    self.im_size = im.size

        return self.im_size

    def chunk(self, start, n):
        log.debug("chunk(start=%d, n=%d)", start, n)
        end = min(start + n, self.N)
        chunk = self.table.iloc[start:end]
        return chunk

    def annotate(self, index, value, column):
        self.table.iloc[index, column] = value

    def write(self):
        self.table.to_csv(self.dbfilename, na_rep='',
                          sep=self.conf["csv_sep"],
                          decimal=self.conf["csv_decimal"],
                          header=False,
                          index=False,
                          float_format=self.conf["float_format"])
        log.info("Saved to %s", self.dbfilename)

    def close(self):
        self.write()
        self.dbfile.close()

    def get_first_unannotated(self, column):
        log.debug("get_first_unannotated(column=%d)", column)
        i = 0
        while not (i >= self.N or np.isnan(self.table.iloc[i, column])):
            i += 1
        return i


class ImageGridTk(tk.Frame):

    def __init__(self, imagedb, master=None):
        super().__init__(master, bg='black')

        # configuration values
        self.conf = Config()
        self.zoom = self.conf["zoom_default"]
        self.border = self.conf["image_border"]
        self.padding = self.conf["image_padding"]
        self.save_every = self.conf["save_every"]
        self.column_out = None
        self.column_in = None
        self.column_path = None

        # image db
        self.imagedb = imagedb

        # button by index in the imagedb
        self.buttons = dict()

        # class value by index in the imagedb
        self.classes = dict()

        # description of the current cass, used when clicked on an image
        self.current_class_desc = None

        # description of default class
        self.default_class_desc = None

        # number of clicks on next button, used to save the list every n click
        self.next_count = 0

        # position of the first grid image in the imagedb
        self.index = self.imagedb.get_first_unannotated(self.column_out)

        # number of images in the grid view, will be updated by update_ui()
        self.num_images = 0

        # last pressed image name
        self.last_pressed = ''

        # bind configure event, to update the image grid
        self.bind("<Configure>", self.on_configure)

        # bind keyboard shortcuts
        if 'key_clipboard' in self.conf:
            log.debug("keyboard shortcut: %s -> on_clipboard", self.conf["key_clipboard"])
            self.master.bind_all(self.conf["key_clipboard"], self.on_clipboard)

        # initialize user interface
        self.init_ui()

    def init_ui(self):
        # initialize toolbar frame and its content
        self.tool = tk.Frame(self)

        # go through class descritions
        self.class_descs = dict()
        for cdesc in self.conf["classes"]:
            self.init_class(cdesc)
            self.class_descs[cdesc['value']] = cdesc
            if cdesc.get('default', False):
                self.default_class_desc = cdesc
            elif cdesc.get('current', False):
                self.current_class_desc = cdesc

        # next prev button
        self.bt_prev = self.create_toolbar_button("Prev",
                                                  key=self.conf.get("key_prev", None),
                                                  cmd=self.on_prev,
                                                  side=tk.LEFT)
        
        self.bt_next = self.create_toolbar_button("Next",
                                                  key=self.conf.get("key_next", None),
                                                  cmd=self.on_next,
                                                  side=tk.LEFT)

        self.bt_next = self.create_toolbar_button("Next and save",
                                                  key=self.conf.get("key_next_and_save", None),
                                                  cmd=self.on_next_and_save,
                                                  side=tk.LEFT)

        self.bt_zoom_in = self.create_toolbar_button("+",
                                                     key=self.conf.get("key_zoom_in", None),
                                                     cmd=self.on_zoom_in,
                                                     side=tk.RIGHT)

        self.bt_zoom_out = self.create_toolbar_button("-",
                                                      key=self.conf.get("key_zoom_out", None),
                                                      cmd=self.on_zoom_out,
                                                      side=tk.RIGHT)

        # initialize grid
        self.grid = tk.Frame(self)
        self.grid['bg'] = self.conf['background']

        # initialize info line
        self.info = tk.Frame(self)
        self.info_label = tk.Label(self.info, text="text")
        self.info_label.pack(side=tk.LEFT)

        self.tool.pack(side="top", fill="both", expand=False)
        self.grid.pack()
        self.info.pack(side="bottom", fill="both", expand=False)

        self.update_info()

    def init_class(self, desc):
        if "button_all" in desc:
            button = self.create_toolbar_button(**desc["button_all"],
                                                cmd=lambda: self.on_mark_all(desc))
            button.pack(side=tk.LEFT)

        if "button_select" in desc:
            button = self.create_toolbar_button(**desc["button_select"],
                                                cmd=lambda: self.on_select(desc))
            button.pack(side=tk.LEFT)

    def on_configure(self, event):
        log.debug("Configure event: %d, %d", event.width, event.height)
        self.widget_size = (event.width, event.height)
        self.update_grid()
        self.update_info()

    def on_zoom_in(self, event=None):
        log.debug("on_zoom_in() current zoom: %f", self.zoom)
        if self.zoom * self.conf["zoom_step"] <= self.conf["zoom_max"]:
            self.zoom *= self.conf["zoom_step"]
            self.update_grid()
            self.update_info()
        else:
            log.warn("Already maximal zoom.")

    def on_zoom_out(self, event=None):
        log.debug("on_zoom_out() current zoom: %f", self.zoom)
        if self.zoom / self.conf["zoom_step"] >= self.conf["zoom_min"]:
            self.zoom /= self.conf["zoom_step"]
            self.update_grid()
            self.update_info()
        else:
            log.warn("Already minimal zoom.")

    def on_zoom_reset(self):
        self.zoom = self.conf["zoom_default"]
        self.update_grid()
        self.update_info()

    def on_mark_all(self, aclass):
        log.debug("on_mark_all(aclass=%s)", aclass["name"])
        for key in self.buttons.keys():
            self.annotate(key, aclass)

    def on_select(self, aclass):
        log.debug("on_select(aclass=%s)", aclass["name"])
        self.current_class_desc = aclass
        self.update_info()

    def on_next(self, event=None):
        log.debug("on_next()")

        if self.index + self.num_images > self.imagedb.N:
            log.debug("End of file!")
        else:
            self.index += self.num_images

        self.update_grid()
        self.update_info()

    def on_next_and_save(self, event=None):
        log.debug("on_next_and_save()")

        self.next_count += 1
        self.store_annotations()

        if self.next_count >= self.save_every:
            self.next_count = 0
            self.imagedb.write()

        self.on_next()

    def on_prev(self, event=None):
        log.debug("on_prev()")
        self.index = max(0, self.index - self.num_images)
        self.update_grid()
        self.update_info()

    def on_click(self, index):
        log.debug("on_click(index=%d, img=%s)", index, self.buttons[index]['text'])

        # store last pressed image
        self.last_pressed = self.buttons[index]['text']

        # update info to show last pressed
        self.update_info()

        if self.current_class_desc is None:
            log.warn("No active class")
            return

        # annotate image
        self.annotate(index, self.current_class_desc)

    def on_clipboard(self, event=None):
        log.debug("on_clipboard()")
        self.master.clipboard_clear()
        self.master.clipboard_append(self.last_pressed)

    def store_annotations(self):
        # store annotations
        for key, val in self.classes.items():
            self.imagedb.annotate(key, val, self.column_out)

    def annotate(self, index, cdesc):
        log.debug("annotate(index=%d)", index)
        self.classes[index] = cdesc['value']
        self.update_image_button(index, cdesc)

    def update_image_button(self, index, cdesc):
        button = self.buttons[index]
        button.configure(bg=cdesc['color'],
                         activebackground=cdesc['color'])

    def clear_all(self):
        log.debug("clear_all()")
        for button in self.buttons.values():
            button.grid_forget()
            button.destroy()
        self.buttons = dict()

    def update_info(self):
        log.debug("update_info()")

        text = []

        text.append("index: {}".format(self.index))

        if self.num_images > 0:
            text.append("images: {}".format(self.num_images))

        if self.current_class_desc:
            text.append("select: {}".format(self.current_class_desc["name"]))
            self.info["bg"] = self.current_class_desc["color"]
            self.info_label["bg"] = self.current_class_desc["color"]
        text.append("zoom: {:1.3f}".format(self.zoom))

        if self.last_pressed is not None and len(self.last_pressed) > 0:
            text.append("last: {}".format(self.last_pressed))

        self.info_label['text'] = " | ".join(text)

    def update_grid(self):
        # log.debug("update ui size: %s zoom: %f", size, zoom)
        self.clear_all()

        # get size of the widget
        widget_width, widget_height = self.widget_size
        log.debug("Widget size w: {} h: {}".format(widget_width, widget_height))

        # size of the image
        image_width, image_height = self.imagedb.im_size
        log.debug("Image size w: {} h: {}".format(image_width, image_height))

        # compute number of rows and collumns
        rows = int(widget_height // (image_height*self.zoom + 2*self.padding + 2*self.border + 5))
        cols = int(widget_width // (image_width*self.zoom + 2*self.padding + 2*self.border + 5))

        log.debug("Grid size c: {} r: {}".format(cols, rows))

        # cnfigure padding
        for i in range(rows):
            self.rowconfigure(i, pad=self.padding)

        for j in range(cols):
            self.columnconfigure(j, pad=self.padding)

        self.num_images = rows * cols

        chunk = self.imagedb.chunk(self.index, self.num_images)

        if len(chunk) <= 0:
            log.warning("No images!")
            return

        # create all buttons
        k = 0
        for i,j in islice(product(range(rows), range(cols)), len(chunk)):
            image_index = self.index + k

            cdesc = self.default_class_desc
            self.classes[image_index] = cdesc['value']
            button = self.create_image_button(index=image_index,
                                              zoom=self.zoom,
                                              cdesc=cdesc)
            button.grid(row=i, column=j)
            self.buttons[image_index] = button
            k += 1

        # pack frame
        self.grid.pack()

    def create_image_button(self, index, cdesc, zoom=1):
        log.debug("create_image_button(index=%d,...)", index)
        button = tk.Button(self.grid,
                           bd=self.border,
                           bg=cdesc['color'],
                           activebackground=cdesc['color'],
                           relief=tk.FLAT)

        button["text"] = str(index)
        button["command"] = lambda: self.on_click(index)
        image = self.imagedb.imread(index)

        if zoom != 1:
            image = image.resize((int(image.size[0]*zoom),int(image.size[1]*zoom)))
        photo = ImageTk.PhotoImage(image)
        button["image"] = photo
        button.photo = photo
        return button

    def create_toolbar_button(self, text, cmd=None, key=None, side=tk.RIGHT):
        log.debug("create_toolbar_button(text=%s,...)", text)
        button = tk.Button(self.tool)
        button["text"] = text

        if cmd is not None:
            button["command"] = cmd
            log.debug("Register button %s command %s.%s", text, cmd.__module__, cmd.__name__)

            if key:
                self.master.bind_all(key, cmd)
                log.debug("Bind %s to %s.%s", key, cmd.__module__, cmd.__name__)
        button.pack(side=side)
        return button


class KlikatkoApp(tk.Frame):

    def __init__(self, imagedb, master=None):
        super().__init__(master)
        self.imagedb = imagedb
        self.pack()
        self.init_ui()

    def init_ui(self):
        # main window
        self.master.title("Klikatko")
        # grid view
        self.grid = ImageGridTk(self.imagedb, self)
        self.grid.pack(fill=tk.BOTH, expand=True)
        self.pack(fill=tk.BOTH, expand=True)

        return

    def add_button(self, master, text, command=None, shortcut=None, side="right"):
        log.debug("Adding button: %s", text)
        button = tk.Button(master)
        button["text"] = text
        button.pack(side=side)

        if command is not None:
            button["command"] = command
            log.debug("Register button %s command %s", text, str(command))

            if shortcut is not None:
                self.master.bind(shortcut, command)
                log.debug("Bind %s to %s", shortcut, str(command))
        return button

    def on_quit(self, event=None):
        log.info("Quiting")
        self.imagedb.write()
        self.master.destroy()

    def on_test(self, event=None):
        log.debug("Received test event: %s", str(event))

    def on_mouse_motion(self, event):
        x, y = event.x, event.y
        log.debug('{}, {}'.format(x, y))
        log.debug(str(event))


def pd_ensure_columns(df, n, val=np.nan):
    """Ensure number of columns of pandas frame"""
    log.debug("pd_ensure_columns(df, n=%d, val=%s)", n, str(val))
    M, N = df.shape

    for i in range(n - N):
        df[n+i] = val

    return df


def setup_logging(level):
    log.setLevel(level)
    formatter = logging.Formatter('%(name)s:%(levelname)s: %(message)s')
    ch = logging.StreamHandler()
    ch.setLevel(level)
    ch.setFormatter(formatter)

    log.addHandler(ch)


if __name__ == "__main__":
    main()
