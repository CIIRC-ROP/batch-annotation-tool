#!/usr/bin/env python3

""" klikatko: Annotation tool

Usage:
  klikatko -h | --help
  klikatko [options] <csvfile>

Options:
  -h, --help
  --config CONFIG    Specifi config file [default: klikatko.json]
  --debug            Run in debug mode
  --fullscreen       Display in fullscreen
"""

from klikatko import Config

from PIL import Image, ImageTk
from docopt import docopt
import numpy as np
import tkinter as tk
from tkinter import ttk
import logging
import pandas as pd
import os

# main logger
log = logging.getLogger("Klikatko")


def main():
    opt = docopt(__doc__)
    csvfile = opt["<csvfile>"]

    # setup logging
    setup_logging(level = "DEBUG" if opt["--debug"] else "INFO")

    # initialize config
    conf = Config(opt["--config"])

    # prepare database
    sampledb = SampleDB(csvfile, 1)

    root = tk.Tk()

    if opt['--fullscreen']:
        root.geometry("{0}x{1}+0+0".format(root.winfo_screenwidth(), root.winfo_screenheight()))
    else:
        root.geometry(conf["geometry"])
    app = KlikatkoApp(sampledb,master=root)

    # set quit functions
    root.protocol("WM_DELETE_WINDOW", app.on_quit)

    # run main loop
    app.mainloop()


class SampleDB(object):

    def __init__(self, filename, outcolumn, incolumn=None, default=''):
        self.dbfilename = filename
        log.info("DB file: %s", self.dbfilename)

        self.base_path = os.path.dirname(self.dbfilename)
        log.info("Base path: %s", self.base_path)

        # get image size
        self.first_image = None
        self.im_size = None
        log.info("Image size: %s", str(self.get_image_size()))

        # config
        self.conf = Config()
        self.column_path = self.conf["column_path"]
        self.column_in   = self.conf["column_in"]
        self.column_out  = self.conf["column_out"]

        # table of paths and annotations
        self.table = pd.read_csv(self.dbfilename,
                                 sep=self.conf["csv_sep"],
                                 decimal=self.conf["csv_decimal"],
                                 header=None)

        self.table = pd_ensure_columns(self.table, max(self.column_in, self.column_out))

    def get_image_size(self):
        if self.im_size is None:
            # get size of the imag
            with open(self.dbfilename, "r") as f:
                _ = f.readline()
                line = f.readline()
                imagefile = line.split(";")[0]
                self.first_image = os.path.join(self.base_path, imagefile)

                with Image.open(self.first_image) as im:
                    self.im_size = im.size

        return self.im_size

    def chunk(self, start, n):
        end = start + n
        chunk = self.table.iloc[start:end]
        return chunk

    def annotate(self, index, value, column):
        self.table.iloc[index,column] = value

    def write(self):
        pass

    def close(self):
        self.write()
        self.dbfile.close()

class ImageGridTk(tk.Frame):

    def __init__(self, imagedb, master=None):
        super().__init__(master, bg='black')
        self.conf = Config()
        self.column_path = self.conf["column_path"]
        self.column_in   = self.conf["column_in"]
        self.column_out  = self.conf["column_out"]

        self.imagedb = imagedb
        self.buttons = dict()
        self.bind("<Configure>", self.on_configure)

        self.zoom = self.conf["zoom_default"]
        self.border = self.conf["image_border"]
        self.padding = self.conf["image_padding"]
        self.current_class_desc = None

        self.index = 0
        self.num_images = 0
        self.init_ui()


    def init_ui(self):

        # initialize toolbar frame and its content
        self.tool = tk.Frame(self)

        self.class_descs = dict()
        for cdesc in self.conf["classes"]:
            self.init_class(cdesc)
            self.class_descs[cdesc['value']] = cdesc
            if cdesc['default']:
                self.current_class_desc = cdesc


        self.bt_next = self.create_toolbar_button("Next",
                                                  key="<Return>",
                                                  cmd=self.on_next,
                                                  side=tk.LEFT)

        self.bt_zoom_in = self.create_toolbar_button("+",
                                                     cmd=self.on_zoom_in,
                                                     side=tk.RIGHT)

        self.bt_zoom_out = self.create_toolbar_button("-",
                                                      cmd=self.on_zoom_out,
                                                      side=tk.RIGHT)

        # initialize grid
        self.grid = tk.Frame(self)

        # initialize info line
        self.info = tk.Frame(self)
        self.info_label = tk.Label(self.info, text="text")
        self.info_label.pack(side=tk.LEFT)

        self.tool.pack(side="top", fill="both", expand=False)
        self.grid.pack()
        self.info.pack(side="bottom", fill="both", expand=False)

        self.update_info()

    def init_class(self, desc):
        if "button_all" in desc:
            button = self.create_toolbar_button(**desc["button_all"],
                                             cmd=lambda: self.on_mark_all(desc))
            button.pack(side=tk.LEFT)

        if "button_select" in desc:
            button = self.create_toolbar_button(**desc["button_select"],
                                             cmd=lambda: self.on_select(desc))
            button.pack(side=tk.LEFT)


    def on_configure(self, event):
        log.debug("Configure event: %d, %d", event.width, event.height)
        self.widget_size = (event.width, event.height)
        self.update_grid()
        self.update_info()

    def on_zoom_in(self):
        log.debug("on_zoom_in() current zoom: %f", self.zoom)
        if self.zoom + self.conf["zoom_step"] <= self.conf["zoom_max"]:
            self.zoom += self.conf["zoom_step"]
            self.update_grid()
            self.update_info()
        else:
            log.warn("Already maximal zoom.")

    def on_zoom_out(self):
        log.debug("on_zoom_out() current zoom: %f", self.zoom)
        if self.zoom - self.conf["zoom_step"] >= self.conf["zoom_min"]:
            self.zoom -= self.conf["zoom_step"]
            self.update_grid()
            self.update_info()
        else:
            log.warn("Already minimal zoom.")

    def on_zoom_reset(self):
        self.zoom = self.conf["zoom_default"]
        self.update_grid()
        self.update_info()

    def on_mark_all(self, aclass):
        log.debug("on_mark_all(aclass=%s)", aclass["name"])
        for key in self.buttons.keys():
            self.annotate(key, aclass)

    def on_select(self, aclass):
        log.debug("on_select(aclass=%s)", aclass["name"])
        self.current_class_desc = aclass
        self.update_info()

    def on_next(self, event=None):
        log.debug("on_next()")
        self.index += self.num_images
        self.update_grid()
        self.update_info()

    def on_prev(self, event=None):
        log.debug("on_prev()")
        self.index = max(0, self.index - self.num_images)
        self.update_grid()
        self.update_info()

    def on_click(self, index):
        log.debug("on_click(index=%d)", index)

        if self.current_class_desc is None:
            log.warn("No active class")
            return

        self.annotate(index, self.current_class_desc)

    def annotate(self, index, cdesc):
        log.debug("annotate(index=%d)", index, )
        self.update_image_button(index, cdesc)

    def update_image_button(self, index, cdesc):
        button = self.buttons[index]
        button.configure(bg=cdesc['color'],
                         activebackground=cdesc['color'])

    def clear_all(self):
        log.debug("clear_all()")
        for button in self.buttons.values():
            button.grid_forget()
            button.destroy()
        self.buttons = dict()

    def update_info(self):
        log.debug("update_info()")

        text = []

        text.append("index:{}".format(self.index))

        if self.num_images > 0:
            text.append("images:{}".format(self.num_images))

        if self.current_class_desc:
            text.append("select:{}".format(self.current_class_desc["name"]))
            self.info["bg"] = self.current_class_desc["color"]
            self.info_label["bg"] = self.current_class_desc["color"]
        text.append("zoom:{}".format(self.zoom))

        self.info_label['text'] = " | ".join(text)

    def update_grid(self):
        # log.debug("update ui size: %s zoom: %f", size, zoom)
        self.clear_all()

        # get size of the widget
        widget_width, widget_height = self.widget_size
        log.debug("Widget size w: {} h: {}".format(widget_width, widget_height))

        # size of the image
        image_width, image_height = self.imagedb.im_size
        log.debug("Image size w: {} h: {}".format(image_width, image_height))

        # compute number of rows and collumns
        rows = int(widget_height // (image_height*self.zoom + 2*self.padding + 2*self.border + 5))
        cols = int(widget_width // (image_width*self.zoom + 2*self.padding + 2*self.border + 5 ))

        log.debug("Grid size c: {} r: {}".format(cols, rows))

        # cnfigure padding
        for i in range(rows):
            self.rowconfigure(i, pad=self.padding)

        for j in range(cols):
            self.columnconfigure(j, pad=self.padding)

        self.num_images = rows * cols

        chunk = self.imagedb.chunk(self.index, self.num_images)

        # create all buttons
        k = 0
        for i in range(rows):
            for j in range(cols):
                image_path = os.path.join(self.imagedb.base_path, chunk.iloc[k,0])
                image_class = chunk.iloc[k,1]
                image_index = self.index + k

                button = self.create_image_button(image_path, index=image_index, zoom=self.zoom)
                button.grid(row=i, column=j)
                self.buttons[image_index] = button
                k += 1

        # pack frame
        self.grid.pack()

    def create_image_button(self, imagename, index, zoom=1):
        log.debug("create_image_button(imagename=%s,...)", imagename)
        button = tk.Button(self.grid,
                           bd=self.border,
                           bg='red3',
                           activebackground="red",
                           relief=tk.FLAT)

        button["text"] = imagename
        button["command"] = lambda : self.on_click(index)
        image = Image.open(imagename)

        if zoom != 1:
            image = image.resize((int(image.size[0]*zoom),int(image.size[1]*zoom)))
        photo = ImageTk.PhotoImage(image)
        button["image"] = photo
        button.photo = photo
        return button

    def create_toolbar_button(self, text, cmd=None, key=None, side=tk.RIGHT):
        log.debug("create_toolbar_button(text=%s,...)", text)
        button = tk.Button(self.tool)
        button["text"] = text

        if cmd is not None:
            button["command"] = cmd
            log.debug("Register button %s command %s.%s", text, cmd.__module__, cmd.__name__)

            if key:
                self.master.bind_all(key, cmd)
                log.debug("Bind %s to %s.%s", key, cmd.__module__, cmd.__name__)
        button.pack(side=side)
        return button


class KlikatkoApp(tk.Frame):

    def __init__(self, imagedb, master=None):
        super().__init__(master)
        self.imagedb = imagedb
        self.pack()
        self.init_ui()

    def init_ui(self):
        # main window
        self.master.title("Klikatko")
        # grid view
        self.grid = ImageGridTk(self.imagedb, self)
        self.grid.pack(fill=tk.BOTH, expand=True)
        self.pack(fill=tk.BOTH, expand=True)

        return

    def add_button(self, master, text, command=None, shortcut=None, side="right"):
        log.debug("Adding button: %s", text)
        button = tk.Button(master)
        button["text"] = text
        button.pack(side=side)

        if command is not None:
            button["command"] = command
            log.debug("Register button %s command %s", text, str(command))

            if shortcut is not None:
                self.master.bind(shortcut, command)
                log.debug("Bind %s to %s", shortcut, str(command))
        return button

    def on_quit(self, event=None):
        log.info("Quiting")
        self.master.destroy()

    def on_test(self, event=None):
        log.debug("Received test event: %s", str(event))

    def on_mouse_motion(self,event):
        x, y = event.x, event.y
        log.debug('{}, {}'.format(x, y))
        log.debug(str(event))



def pd_ensure_columns(df, n, val=''):
    """Ensure number of columns of pandas frame"""
    M,N = df.shape

    for i in range(n - N):
        df[:,n+i] = pd.Series([val]*M, index = df.index)
    return df

def setup_logging(level):
    log.setLevel(level)
    formatter = logging.Formatter('%(name)s:%(levelname)s: %(message)s')
    ch = logging.StreamHandler()
    ch.setLevel(level)
    ch.setFormatter(formatter)

    log.addHandler(ch)


if __name__ == "__main__":
    main()
